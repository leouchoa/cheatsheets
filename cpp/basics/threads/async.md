# Async

It's an alternative to the promise-future approach to remove a lot of
boilerplate code that it entails. Notes:

- `async` returns a future, which can be used to retrieve the value that is
returned by the function.

- A promise, as with `std::thread`, is no longer needed, so the code becomes
much shorter.

- Also, we do not need to call join() any more. With async, the thread
destructor will be called automatically

- One of the major differences between `std::thread` and `std::async` is that with
the latter, the system decides wether the associated function should be run
asynchronously or synchronously. By adjusting the launch parameters of `std::async`
manually, we can directly influence wether the associated thread function will
be executed synchronously or asynchronously.

```cpp
#include <cmath>
#include <future>
#include <iostream>
#include <memory>
#include <thread>

double divideByNumber(double num, double denom) {
  // print system id of worker thread
  std::cout << "Worker thread id = " << std::this_thread::get_id() << std::endl;

  std::this_thread::sleep_for(std::chrono::milliseconds(500)); // simulate work

  if (denom == 0)
    throw std::runtime_error("Exception from thread#: Division by zero!");

  return num / denom;
}

int main() {
  // print system id of worker thread
  std::cout << "Main thread id = " << std::this_thread::get_id() << std::endl;

  double num = 42.0, denom = 2.0;

  // "async" instead of "deferred", we would enforce an asynchronous execution
  // whereas the option "any" would leave it to the system to decide - which is
  // the default.
  std::future<double> ftr =
      std::async(std::launch::deferred, divideByNumber, num, denom);

  // retrieve result within try-catch-block
  try {
    double result = ftr.get();
    std::cout << "Result = " << result << std::endl;
  } catch (std::runtime_error e) {
    std::cout << e.what() << std::endl;
  }

  return 0;
}
```

## `std::thread` VS `std::async`

Internally, `std::async` creates a promise, gets a future from it and runs a
template function that takes the promise, calls our function and then either
sets the value or the exception of that promise - depending on function
behavior. The code used internally by `std::async` is more or less identical to
the code in the `sort_of_async_internal_impl.cpp` file, except that this time
it has been generated by the compiler.

Also, `std::async` makes it possible to control the amount of concurrency by
passing an optional launch parameter, which enforces either synchronous (`std::
launch::deferred`) or asynchronous (`std::launch::async`) behavior. This
ability, especially when left to the system, allows us to prevent an overload
of threads, which would eventually slow down the system as threads consume
resources for both management and communication.

If we were to use too many threads, the increased resource consumption would
outweigh the advantages of parallelism and slow down the program. By leaving
the decision to the system, we can ensure that the number of threads is chosen
in a carefully balanced way that optimizes runtime performance by looking at
the current workload of the system and the multi-core architecture of the system.

## Final Example

```cpp
#include <chrono>
#include <cmath>
#include <future>
#include <iostream>
#include <thread>
#include <vector>

void workerFunction(int n) {
  // print system id of worker thread
  std::cout << "Worker thread id = " << std::this_thread::get_id() << std::endl;

  // perform work
  for (int i = 0; i < n; ++i) {
    sqrt(12345.6789);
  }
}

int main() {
  // print system id of worker thread
  std::cout << "Main thread id = " << std::this_thread::get_id() << std::endl;

  // start time measurement
  std::chrono::high_resolution_clock::time_point t1 =
      std::chrono::high_resolution_clock::now();

  // launch various tasks
  std::vector<std::future<void>> futures;

  int nLoops = 10, nThreads = 5;
  for (int i = 0; i < nThreads; ++i) {
    futures.emplace_back(std::async(workerFunction, nLoops));
  }

  // wait for tasks to complete
  for (const std::future<void> &ftr : futures)
    ftr.wait();

  // stop time measurement and print execution time
  std::chrono::high_resolution_clock::time_point t2 =
      std::chrono::high_resolution_clock::now();
  auto duration =
      std::chrono::duration_cast<std::chrono::microseconds>(t2 - t1).count();
  std::cout << "Execution finished after " << duration << " microseconds"
            << std::endl;

  return 0;
}
```
